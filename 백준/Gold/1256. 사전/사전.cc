#include <iostream>

using namespace std;

static long d[201][201]; // n+m 의 범위 최대 = 200

int main() {

    // a, z 개수가 각각 n, m 일때, 이 문자로 만들 수 있는 모든 경우의 수는..
    // n+m개에서 n개를 뽑는 경우의 수 or m개를 뽑는 경우의 수와 동일하다. (조합)
    
    for (int i = 0; i <= 200; i++) {
        for (int j = 0; j <= i; j++) {
            
            if (j == 0 || j == i) { // 초기화
                d[i][j] = 1;
            } else { // 점화
                
                d[i][j] = d[i - 1][j] + d[i - 1][j - 1];
                
                if (d[i][j] > 1000000000) { // K 범위 초과
                    d[i][j] = 1000000001; // K 최댓값으로 할당
                }
            }
        }
    }
    
    int n = 0; // a 개수
    int m = 0; // z 개수
    int k = 0; // 순서(문제)
    
    cin >> n >> m >> k;
    
    if (d[n + m][m] < k) { // 주어진 문자로 만들수 있는 모든 경우의 수보다 k가 크면 -1 출력
        cout << "-1";
        return 0;
    }
    
    // 위에서 d[i][j] 로 총 경우의 수를 구했다.
    // 이제 아래에서는 역산을 할 것이다.
    // a=2, z=2 일때..
    // d[4][2] = d[3][2] + d[3][1]
    // d[4][2] : 총 경우의 수
    // d[3][2] : 3개의 문자 중, z 2개 사용 -> 첫번째 문자가 a 라는 의미로 볼 수 있다.
    // d[3][1] : 3개의 문자 중, z 1개 사용 -> 첫번째 문자가 z 라는 의미로 볼 수 있다.
    // 따라서..
    // d[3][2] 와 k 를 비교하여..
    // k 가 크면, 첫문자 z 인 것이고
    // k 가 작으면, 첫문자 a 인 것이다.
    // 이러한 논리로 역산을 해본다. (이진 탐색과 비슷한 전개인듯..?)
    
    while (n != 0 || m != 0) { // 남은 a, z 가 없을 때까지 수행
        
        if (d[n + m - 1][m] >= k) { // d[3][2] 와 비교
            cout << "a";
            n--;
        } else {
            cout << "z";
            k = k - d[n + m - 1][m]; // k 값 업데이트
            m--;
        }
    }
    
    return 0;
}