#include <iostream>

using namespace std;

static int n;
static int mod = 1000000000;
static long d[1000001];

int main() {
    
    cin >> n;
    
    // d[i] : i 명이 선물을 교환할 수 있는 모든 경우의 수
    // d[i] = (n - 1) * (d[i - 1] + d[i - 2])
    // a라는 사람이 b라는 사람에게 선물을 줬다 치자
    // 그러면.. 두가지 경우가 생긴다.
    // 1. b 도 a 에게 선물을 준경우.. -> d[i - 2] 이다. (2명이 정해졌으므로 -2)
    // 2. b 는 a 가 아닌 다른 사람에게 선물을 준경우.. -> d[i - 1] 이다.
    // 그런데..
    // 1, 2 번 케이스 모두 a가 b에게 선물을 준 상황에서 고려 했으므로 전체 (n - 1) 을 곱해준다.
    
    // 참고
    // 2번 케이스에서 d[i - 1] 값에 b 가 a 에게 반드시 선물을 안준다는 보장이 없을 것 같은 막연한 생각이 들 수 있음.
    // 논리적으로 보면..
    // a -> b 이고 b -> c 일 것이다. 여기서 b를 삭제(n - 1) 시키면, a -> c 가 되면서
    // d[n - 1] (b 가 빠짐) 이 되므로 b 가 a 에게 선물을 줄 수 없다.
    
    
    // 초기화
    d[1] = 0; // 혼자서는 선물 교환 X
    d[2] = 1; // 두명일 경우 경우의 수는 1
    
    // 점화
    for (int i = 3; i <= n; i++) {
        d[i] = (i - 1) * (d[i - 1] + d[i - 2]) % mod;
    }
    
    cout << d[n];
    
    return 0;
}